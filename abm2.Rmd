---
title: "Theoretical model"
bibliography: references.bib
link-citations: true
date: "Last compiled on `r format(Sys.time(), '%d-%m-%Y')`"
output: 
  html_document:
    css: tweaks.css
    toc:  true
    toc_float: true
    number_sections: true
    toc_depth: 4
    code_folding: show
    code_download: yes
---



```{r, globalsettings, echo=FALSE, warning=FALSE, results='hide', message=FALSE}
library(knitr)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, message = FALSE,comment = "#>", cache=TRUE, class.source=c("test"), class.output=c("test3"))
options(width = 100)
rgl::setupKnitr()

colorize <- function(x, color) {sprintf("<span style='color: %s;'>%s</span>", color, x) }
```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
#klippy::klippy(color = 'darkred')
#klippy::klippy(tooltip_message = 'Click to copy', tooltip_success = 'Done')
```

---

# Getting started

To copy the code, click the button in the upper right corner of the code-chunks.

## clean up

```{r, clean_up, results='hide'}
rm(list=ls())
gc()
```

<br>

## custom functions

We defined a number custom functions, at `r xfun::embed_file("./custom_functions.R")`.

```{r, custom_functions}
source("./custom_functions.R")
```

<br>

## necessary packages

```{r, packages}
#packages = c("tidyverse", "igraph", "ggplot2", "ggpubr", "plotly", "parallel", "foreach", #"doParallel", "ggh4x", "grid", "gridExtra", "patchwork", "ggplotify", "ggraph", "gganimate", #"RColorBrewer", "ggtext", "magick")

packages = c("tidyverse", "igraph", "ggplot2", "parallel", "doParallel", "foreach")

invisible(fpackage.check(packages))
rm(packages)
```

---

# Parameter spaces

```{r}
# full factorial design
# A) configuration model
n <- 1000
conf <- expand.grid(
  group_size = n,
  minority_prop = c(0.05, 0.1, 0.15, 0.20),
  min_deg = c(2),
  max_deg = sqrt(n),
  dist = c("power-law", "log-normal"),
  alpha = c(2.4, 2.7, 3),
  r_kk = seq(-0.4, 0.1, length.out = 6),
  rho_kx = seq(0, 0.5, length.out = 6),
  s = 15,
  e = 10,
  w = 40,
  z = 50,
  lambda1 = 4.3,
  lambda2 = 1.8
)

fshowdf(conf, caption = "full factorial design for configuration model")

# B) watts-strogatz
ws <- expand.grid(
  group_size = n,
  minority_prop = c(0.05, 0.1, 0.15, 0.20),
  min_deg = c(2,3),
  p = c(0.07, 0.15, 1),
  r_kk = seq(-0.4, 0.1, length.out = 6),
  rho_kx = seq(0, 0.6, length.out = 6),
  s = 15,
  e = 10,
  w = 40,
  z = 50,
  lambda1 = 4.3,
  lambda2 = 1.8
)

fshowdf(ws, caption = "full factorial design for Watts-Strogatz model")
```

```{r, eval=FALSE}
# number of seeds
nIter = 50

# set up parallel backend to increase efficiency
ncores <- detectCores() - 1 
cl <- makeCluster(ncores)
registerDoParallel(cl)

# parallel processing using foreach
system.time({
  foreach(i = 1:nrow(conf), .combine = 'c', .packages = c("igraph", "tidyverse")) %dopar% {
    
    cfg <- conf[i, ] # get configuration from full factorial
    results <- list()  # temporary storage for all iterations of this config
    
    for (iter in 1:nIter) {
      seed <- 123 + iter
      set.seed(seed)
      
      # generate degree sequence
      degseq <- fdegseq(n = cfg$group_size, alpha = cfg$alpha, k_min = cfg$min_deg, k_max = cfg$max_deg, seed = seed, dist = cfg$dist)
      
      # construct network
      network <- sample_degseq(degseq, method = "vl")
      
      # assign roles
      V(network)$role <- sample(
        c(
          rep("trendsetter", floor(cfg$group_size * cfg$minority_prop)),
          rep("conformist", cfg$group_size - floor(cfg$group_size * cfg$minority_prop))
        )
      )
      
      # rewire and swap
      rewired_network <- frewire_r(network, cfg$r_kk, verbose = FALSE, max_iter = 1e5)
      final_network <- fswap_rho(rewired_network, cfg$rho_kx, verbose = FALSE, max_iter = 1e4)
      actual_r <- assortativity_degree(rewired_network)
      final_rho <- fdegtraitcor(final_network)$cor
      
      # set initial action
      V(final_network)$action <- ifelse(V(final_network)$role == "trendsetter", 1, 0)
      
      # calculate global majority illusion
      mi <- fcalculate_majority_illusion(final_network)
      
      # run simulation
      sim <- fabm(
        network = final_network,
        params = list(
          s = cfg$s, e = cfg$e, w = cfg$w, z = cfg$z,
          lambda1 = cfg$lambda1, lambda2 = cfg$lambda2
        )
      )
      
      sim <- list(
        outcomes = sim$outcomes,
        equilibrium = sim$equilibrium
      )
      
      # combine all into a single entry per iteration
      results[[iter]] <- list(
        config_id = i,
        dist = cfg$dist,
        alpha = cfg$alpha,
        target_r = cfg$r_kk,
        actual_r = actual_r,
        target_rho = cfg$rho_kx,
        actual_rho = final_rho,
        mi = mi,
        seed = seed,
        sim = sim
      )
    }
    
    # save all iterations for this configuration as a single file
    saveRDS(results, file = paste0("./sims/results_config_", i, ".rds"))
  }
})
  
# stop cluster
stopCluster(cl)
```

