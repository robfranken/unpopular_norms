---
title: "ABM"
bibliography: references.bib
link-citations: true
date: "Last compiled on `r format(Sys.time(), '%d-%m-%Y')`"
output: 
  html_document:
    css: tweaks.css
    toc:  true
    toc_float: true
    number_sections: true
    toc_depth: 4
    code_folding: show
    code_download: yes
---

```{r, globalsettings, echo=FALSE, warning=FALSE, results='hide', message=FALSE}
library(knitr)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, message = FALSE,comment = "#>", cache=TRUE, class.source=c("test"), class.output=c("test3"))
options(width = 100)
rgl::setupKnitr()

colorize <- function(x, color) {sprintf("<span style='color: %s;'>%s</span>", color, x) }
```


```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
#klippy::klippy(color = 'darkred')
#klippy::klippy(tooltip_message = 'Click to copy', tooltip_success = 'Done')
```

---  


```{r, results='hide'}
rm(list=ls())
gc()
```

```{r, packages, warning=FALSE, message=FALSE, results='hide'}
fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fshowdf <- function(x, ...) {
    knitr::kable(x, digits = 2, "html", ...) %>%
        kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
        kableExtra::scroll_box(width = "100%", height = "300px")
}

fsave <- function(x, file, location = "./data/processed/", ...) {
    if (!dir.exists(location))
        dir.create(location)
    datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
    totalname <- paste(location, datename, file, sep = "")
    print(paste("SAVED: ", totalname, sep = ""))
    save(x, file = totalname)
}

fload <- function(fileName) {
    load(fileName)
    get(ls()[ls() != "fileName"])
}


packages = c("tidyverse", "igraph", "grid", "cowplot", "purrr", "vioplot")
fpackage.check(packages)
rm(packages)

#library(furrr)
#library(future)
#library(parallel)
```

---

# utility function

```{r}
futility <- function(agent_id, choice, agents, network, params) {
  # get ego and his local neighborhood
  ego <- agents[agent_id, ]
  neighbors <- neighbors(network, ego$id)
  alters <- agents[as.numeric(neighbors), ]
  n <- nrow(alters)

  # count number of neighbors who did (not) follow the trend
  n1 <- sum(alters$choice == 1)
  n0 <- sum(alters$choice == 0)
  
  # calculate expected utility (depending on alters' choices in prior round)
  if(ego$role == "conformist") {
    choice_payoff <- ifelse(choice == 0, params$s, 0)
    coordination_payoff <- ifelse(choice == 0, # normalized by n
                                  (params$w/n) * n0,
                                  (params$z/n) * n1)
  } else {
    choice_payoff <- ifelse(choice == 1, params$e, 0)
    coordination_payoff <- 0
  }
  return(list(utility = choice_payoff + coordination_payoff,
              n1 = n1, n0 = n0))
}
```


----

# plot network graph

```{r}
#visualize the network topology and agent positions (degree-trait correlation)
fplot_graph <- function(graph, main=NULL, layout_algo=NULL, 
                        col1 = "#FFD700", col2 = "#800080") {
  plot(graph,
       main = main,
       layout = layout_algo,
       vertex.label = NA,
       vertex.size = degree(graph) + 2, # node size based on degree
       vertex.color = ifelse(V(graph)$role == "trendsetter", col1, col2),
       edge.width = 0.5,
       edge.color = "darkgrey")
  #add legend
  legend("bottomleft",
         legend = c("Trendsetter", "Conformist"),
         pch = 21,
         col = c(col1,col2),
         pt.bg = c(col1,col2),
         pt.cex = 3,
         bty = "n")
}
```

----

# scale-free network

## preferential attachment model

```{r}
# scale-free network using preferential attachment algorithm
n = 96
m = 3
alpha = 1
t = .1
network <- sample_pa(n = n, m = m, power = alpha, directed = FALSE)
V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))
sort(degree(network))
fplot_graph(network)
``` 


---


## configuration model

```{r}
# generate random graphs based on a degree sequence generated by a power law distribution
fdegseq <- function(n, alpha, k_min = 1, k_max = n-1, seed = NULL) {

  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  # sample degree sequence
  degseq <- sample(
    k_min:k_max, 
    size = n, 
    replace = TRUE, 
    prob = (1 / (k_min:k_max))^alpha) 
  # correct the degree sequence if its sum is odd (necessary for the configuration model)
  if( sum(degseq) %% 2 != 0) {
    degseq[1] <- degseq[1] + 1
  }
  return(degseq)
}
  

degseq <- fdegseq(n=96, alpha=2.4, k_min=3)

network <- sample_degseq(degseq, method = "vl")
is_simple(network)
sort(degree(network))

# randomly assign roles, based on proportion trendsetters
V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))

#visualize graph
fplot_graph(network)
``` 

---

# erdos-renyi random graph

```{r}
# to produce random networks with same average degree; tweak edge probability
# <k> = p * (n-1); with p being edge probability
# p = <k> / (n-1)

# loop over a higher number of simulated configuration model to get an accurate estimate of average degree <k> in scale-free networks
nIter <- 1e3
alphas <- c(2.1, 2.4, 3.1)  
kmean <- list() 

for (alpha in alphas) {
  kmean[[as.character(alpha)]] <- numeric(nIter)
  for (i in 1:nIter) {
    try({
      degseq <- fdegseq(n = 96, alpha = alpha, k_min = 3)  
      network <- sample_degseq(degseq, method = "vl")  
      kmean[[as.character(alpha)]][i] <- mean(degree(network)) 
    }, silent = TRUE) 
  }
}

n <- 96
plist <- list(
  mean(kmean$`2.1`[kmean$`2.1`!=0]) / (n-1),
  mean(kmean$`2.4`[kmean$`2.4`!=0]) / (n-1),
  mean(kmean$`3.1`[kmean$`3.1`!=0]) / (n-1)
)

par(mfrow=c(1, length(plist)), mar=c(1,1,3,1))
for (i in 1:length(plist)) {
  network <- erdos.renyi.game(96, p=plist[[i]])
  V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))
  fplot_graph(network, main = paste("p =",  round(plist[[i]], 3)))  
}
```

---

# small-world

```{r}
network <- sample_smallworld(dim = 1, size = 96, nei = 3, p = 0.10)
V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))
fplot_graph(network)
```

```{r}
#plot degree distributions side-by-side
er <- erdos.renyi.game(960, p=0.01)
sw <- sample_smallworld(dim = 1, size = 960, nei = 3, p = 0.10)
sf <- sample_degseq(fdegseq(n=960, alpha=2.4, k_min=3), method = "vl")

par(mfrow=c(1,3))
plot(degree_distribution(er),pch=20,xlab="k",ylab="P(k)",las=1,main="Erdos-Renyi random graph",log="xy")
plot(degree_distribution(sw),pch=20,xlab="k",ylab="P(k)",las=1,main="Small-world graph",log="xy")
plot(degree_distribution(sf),pch=20,xlab="k",ylab="P(k)",las=1,main="Scale-free graph",log="xy")
```


---


# rewiring to manipulate degree-assortativity

```{r}
#rewiring function to adjust assortativity (r) to desired level; Newman:
frewire_r <- function(network, target_r, max_iter = 1e5, tol = 0.01, verbose = TRUE) {
  
  current_r <- assortativity_degree(network)
  iteration <- 1
  
  if (verbose) {
    cat("Target assortativity coefficient:", target_r, "\n")
    cat("Starting assortativity coefficient:", current_r, "\n")
    cat("Tolerance:", tol, "\n")
  }
  
  while (abs(current_r - target_r) > tol && iteration < max_iter) {
    
    # get network edges
    edges <- E(network)
    # to edgelist
    edge_list <- ends(network, edges)
    
    # randomly select two pairs of connected nodes
    idx1 <- sample(1:nrow(edge_list), 1)
    idx2 <- sample(1:nrow(edge_list), 1)
    
    # extract node indices
    u1 <- edge_list[idx1, 1] # node 1 of first edge
    v1 <- edge_list[idx1, 2] # node 2 of first edge
    u2 <- edge_list[idx2, 1] # etc
    v2 <- edge_list[idx2, 2] 
    
    # check if the two pairs of connected nodes (u1, v1; u2, v2) are disjoint
    if (length(unique(c(u1, v1, u2, v2))) == 4) {
      # check if there is already an edge across the node-pairs
      # ensure no loops and no duplicate edges
      if (!are_adjacent(network, u1, u2) && !are_adjacent(network, v1, v2) && u1 != v2 && u2 != v1) {
        
        # perform the edge swap (u1,v1) <-> (u2,v2) becomes (u1,v2) <-> (u2,v1)
        new_network <- network # Copy network
        
        # check if the new edges already exist to avoid duplicates
        if (!are_adjacent(new_network, u1, v2) && !are_adjacent(new_network, u2, v1)) {
          # add edges
          new_network <- add_edges(new_network, c(u1, v2, u2, v1))
          # remove edges
          new_network <- delete_edges(new_network, get.edge.ids(new_network, c(u1, v1, u2, v2)))
          
          # new assortativity
          new_r <- assortativity_degree(new_network)
          
          # accept tie swap if it brings us closer to the target assortativity
          if (abs(new_r - target_r) < abs(current_r - target_r)) {
            current_r <- new_r
            network <- new_network
            if (verbose) { 
              cat("Rewiring at iteration", iteration, "brought assortativity closer to target! Current assortativity coefficient:", new_r, "\n")
            }
          }
        }
      }
    }
    iteration <- iteration + 1
  }
  
  if (verbose) {
    cat("Final assortativity coefficient:", current_r, "\n")
    if (abs(current_r - target_r) <= tol) {
      cat("Target reached within tolerance.\n")
    } else {
      cat("Reached maximum iterations without meeting target.\n")
    }
  }
  
  return(network)
}

#initialize scale-free network
degseq <- fdegseq(n=96, alpha=2.4, k_min=3)
network <- sample_degseq(degseq, method = "vl")
V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))

#get current assortativity coefficient
assortativity_degree(network)

#set new targets
frewire_r(network, target_r = -0.2, max_iter = 1e3)
```

---

# swapping traits to manipulate degree-trait correlation

```{r}
# we manipulate degree-trait correlation (rho) by swapping attribute values among the nodes. To increase \rho_{kx}, we randomly choose nodes v_1 with x=1 and v_0 with x=0 and swap their attributes if the degree of the degree of v_0 is greater than that of v_1 (until the desired \rho_{kx} is reached; or it no longer changes).
fdegtraitcor <- function(network){
  roles <- ifelse(V(network)$role == "trendsetter", 1, 0)
  degrees <- degree(network)
  return(list(cor=cor(roles,degrees),roles=roles,degrees=degrees))
}

#swapping function to adjust degree-trait correlation
fswap_rho <- function(network, target_rho, max_iter = 1e3, tol = 0.05, verbose = TRUE) {
  
  current <- fdegtraitcor(network)
  iteration <- 1
  best_network <- network
  best_rho <- current$cor
  
  if (verbose) {
    cat("Target degree-trait correlation:", target_rho, "\n")
    cat("Starting degree-trait correlation:", current$cor, "\n")
    cat("Tolerance:", tol, "\n\n")
  }
  
  while (iteration <= max_iter) {
    # check if we are already within tolerance
    if (abs(current$cor - target_rho) <= tol) {
      if (verbose) cat("Target reached within tolerance at iteration", iteration, ".\n")
      break
    }
    
    # randomly select nodes for swapping
    v1 <- sample(which(current$roles == 1), 1)
    v0 <- sample(which(current$roles == 0), 1)
    
    # get degrees of selected nodes
    k1 <- current$degrees[v1]
    k0 <- current$degrees[v0]
    
    # swap roles if condition k_v0 > k_v1 is met
    if (k0 > k1) {
      current$roles[v1] <- 0
      current$roles[v0] <- 1
      
      # update graph roles
      V(network)$role <- ifelse(current$roles == 1, "trendsetter", "conformist")
      
      # recalculate degree-trait correlation
      current <- fdegtraitcor(network)
      
      # check if this is the closest correlation to the target so far
      if (abs(current$cor - target_rho) < abs(best_rho - target_rho)) {
        best_network <- network
        best_rho <- current$cor
        if (verbose) {
          cat("Trait-swapping at iteration", iteration, "brought correlation closer to target! Current correlation:", current$cor, "\n")
        }
      }
    }
    iteration <- iteration + 1
  }
  
  # check if the final correlation is worse than the best correlation
  final_correlation <- current$cor
  if (abs(final_correlation - target_rho) > abs(best_rho - target_rho)) {
    if (verbose) {
      cat("\nWarning: Final iteration made the correlation worse. Reverting to best observed correlation.\n")
    }
  }
  
  if (verbose) {
    cat("\nFinal degree-trait correlation:", best_rho, "\n")
    if (abs(best_rho - target_rho) <= tol) {
      cat("Target reached within tolerance.\n")
    } else if (iteration > max_iter) {
      cat("Reached maximum iterations without meeting target.\n")
    }
  }
  return(best_network)
}

fdegtraitcor(network)
target = 0.5
fdegtraitcor(fswap_rho(network = network, target_rho = target, tol=0.01))
``` 

```{r, fig.width=12, fig.height=10}
par(mfrow=c(3,3))

# NETWORKS
alpha = 2.4
degseq <- fdegseq(n=96, alpha=alpha, k_min=3)
network <- sample_degseq(degseq, method = "vl")
V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))

network1 <- frewire_r(network, target_r = -0.3, verbose = FALSE)

fplot_graph(network1,
            main=paste0("configuration model\ndegree sequence generated from p(k)~k^{-α}\nN=96; prop. trendsetter = 0.1; α=2.4; k_min=3\nr_kk = ", 
                        round(assortativity_degree(network1),3), 
                        "; p_kx = ", round(fdegtraitcor(network1)$cor,3)))

network2 <- frewire_r(network, target_r = -0.1, verbose = FALSE)

fplot_graph(network2,
            main=paste0("configuration model\ndegree sequence generated from p(k)~k^{-α}\nN=96; prop. trendsetter = 0.1; α=2.4; k_min=3\nr_kk = ", 
                        round(assortativity_degree(network2),3), 
                        "; p_kx = ", round(fdegtraitcor(network2)$cor,3)))

network3 <- fswap_rho(network2, target_rho = 0.5, verbose=FALSE)

fplot_graph(network3,
            main=paste0("configuration model\ndegree sequence generated from p(k)~k^{-α}\nN=96; prop. trendsetter = 0.1; α=2.4; k_min=3\nr_kk = ", 
                        round(assortativity_degree(network3),3), 
                        "; p_kx = ", round(fdegtraitcor(network3)$cor,3)))


# DEGREE ASSORTATIVITY

plot(degree(network), knn(network)$knn, pch=19, xlab = "Node degree (k)", ylab = "Average neighbor degree (<k'>)",
     main = "degree assortativity")
plot(degree(network2), knn(network2)$knn, pch=19, xlab = "Node degree (k)", ylab = "Average neighbor degree (<k'>)",
     main = "degree assortativity")
plot(degree(network3), knn(network3)$knn, pch=19,  xlab = "Node degree (k)", ylab = "Average neighbor degree (<k'>)",
     main = "degree assortativity")


# VIOLIN PLOT OF DEGREE DISTRIBUTION PER ROLE

# extract node degrees
degrees <- degree(network1)
trendsetter_degrees <- degrees[V(network1)$role == "trendsetter"]
conformist_degrees <- degrees[V(network1)$role == "conformist"]

vioplot(trendsetter_degrees, conformist_degrees, 
        names = c("Trendsetters", "Conformists"),
        col = c("#FFD700", "#800080"),
        main = "degree distribution")

degrees2 <- degree(network2)
trendsetter_degrees2 <- degrees2[V(network2)$role == "trendsetter"]
conformist_degrees2 <- degrees2[V(network2)$role == "conformist"]

vioplot(trendsetter_degrees2, conformist_degrees2, 
        names = c("Trendsetters", "Conformists"),
        col = c("#FFD700", "#800080"),
        main = "degree distribution")

degrees3 <- degree(network3)
trendsetter_degrees3 <- degrees3[V(network3)$role == "trendsetter"]
conformist_degrees3 <- degrees3[V(network3)$role == "conformist"]
vioplot(trendsetter_degrees3, conformist_degrees3, 
        names = c("Trendsetters", "Conformists"),
        col = c("#FFD700", "#800080"),
        main = "degree distribution")

```

---

Simulate scale-free networks with independently varied degree distribution, degree assortativity, and degree-trait correlation:


```{r}
# structural parameters
n = 96
k_min = 3
t = 0.1

# target parameters
alphas <- c(2.4, 2.7, 3)
target_r_values <- list(seq(-0.4, -0.15, by = 0.05),
                        seq(-0.35, -0.05, by = 0.05),
                        seq(-0.3, 0.1, by = 0.05)
                        )
names(target_r_values) <- alphas
target_rho_values <- seq(0, 0.6, by = 0.1)

# list for results
results <- list()

for (alpha in alphas) { #loop over alpha
  
  # generate degree sequence from power law with alpha
  degseq <- fdegseq(n = n, alpha = alpha, k_min = k_min, seed = 123)
  
  # create undirected, connected, simple graph using Viger-Latapy algorithm
  network <- sample_degseq(degseq, method = "vl")
  
  # assign roles randomly, based on proportion trendsetter p_t
  V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))
  
  for (target_r in target_r_values[[as.character(alpha)]]) { #loop over target_r values
    rewired_network <- frewire_r(network, target_r, verbose=FALSE)
    actual_r <- assortativity_degree(rewired_network)
    
    for (target_rho in target_rho_values) { #loop over target_rho values
      final_network <- fswap_rho(rewired_network, target_rho, verbose=FALSE)
      final_rho <- fdegtraitcor(final_network)$cor
      
      # store results
      results <- append(results, list(list(
        alpha = alpha,
        target_r = target_r,
        actual_r = actual_r,
        target_rho = target_rho,
        actual_rho = final_rho,
        network = final_network
      )))
    }
  }
}
```


```{r, fig.width=12,fig.height=6}
# function to calculate magnitude of majority illusion; over different network structures;
calculate_majority_illusion <- function(network, threshold = 0.5) {
  roles <- V(network)$role

  #initialize counter for majority illusion
  mi_count <- 0
  
  #loop over conformists
  for (v in V(network)) { 
    if (roles[v] == "conformist") {
      neighbors <- neighbors(network, v)
      trend_neighbors <- sum(roles[neighbors] == "trendsetter")
      prop_trend <- trend_neighbors / length(neighbors)
      
      if (prop_trend > threshold) {
        mi_count <- mi_count + 1
      }
    }
  }
  # return fraction of conformists who have majority illusion
  return(mi_count / sum(roles == "conformist"))
}

plotdata <- do.call(rbind, lapply(results, function(res) {
  alpha <- res$alpha
  r <- res$actual_r
  rho <- res$actual_rho
  network <- res$network
  
  # calculate the majority illusion (i.e., the proportion of conformists whose neighbors meet or exceed threshold φ)
  mi <- calculate_majority_illusion(network)
  
  # create a dataframe
  data.frame(alpha = alpha, 
             r = r, 
             rho = rho, 
             mi = mi)
}))


#make separate dataframes for each level of alpha
alpha1 <- plotdata[plotdata$alpha==unique(plotdata$alpha)[1],]
alpha2 <- plotdata[plotdata$alpha==unique(plotdata$alpha)[2],]
alpha3 <- plotdata[plotdata$alpha==unique(plotdata$alpha)[3],]

#create bins for r (deg-assorativity)
fcreate_bins <- function(data, variable = "r", out=6) {
  rvals <- data[[variable]]
  quant <- quantile(rvals, probs = seq(0, 1, length.out = out)) 
  # generate labels dynamically
  labels <- sapply(1:(length(quant) - 1), function(i) {
    paste0(round(quant[i], 2), " < r ≤ ", round(quant[i + 1], 2))
  })
  # add categories to the dataset
  data$r_cats <- cut(rvals, breaks = quant, include.lowest = TRUE, labels = labels)
  return(data)
}

# apply binning  to each subset
alpha1 <- fcreate_bins(alpha1)
alpha2 <- fcreate_bins(alpha2)
alpha3 <- fcreate_bins(alpha3)


plot1 <- ggplot(alpha1, aes(x = rho, y = mi, color = as.factor(r_cats))) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(se = FALSE, method = "loess") +
  scale_y_continuous(limits = c(-0.05, 0.7)) +
  labs(
    x = expression("degree-trait correlation (" ~ rho[kx] ~ ")"), 
    y = "prop. conformists w/ prop. trendsetter nbh. > φ",      
    color = expression("degree assortativity (" ~ r[kk] ~ ")")
  ) +
  theme(legend.position = c(0.3, 0.8)) + ggtitle(paste0("α=", alpha1$alpha))

plot2 <- ggplot(alpha2, aes(x = rho, y = mi, color = as.factor(r_cats))) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(se = FALSE, method = "loess") +
  scale_y_continuous(limits = c(-0.05, 0.7)) +
  labs(
    x = expression("degree-trait correlation (" ~ rho[kx] ~ ")"), 
    y = "prop. conformists w/ prop. trendsetter nbh. > φ",      
    color = expression("degree assortativity (" ~ r[kk] ~ ")")
  ) +
  theme(legend.position = c(0.3, 0.8)) + ggtitle(paste0("α=", alpha2$alpha))

plot3 <- ggplot(alpha3, aes(x = rho, y = mi, color = as.factor(r_cats))) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(se = FALSE, method = "loess") +
  scale_y_continuous(limits = c(-0.05, 0.7)) +
  labs(
    x = expression("degree-trait correlation (" ~ rho[kx] ~ ")"), 
    y = "prop. conformists w/ prop. trendsetter nbh. > φ",      
    color = expression("degree assortativity (" ~ r[kk] ~ ")")
  ) +
  theme(legend.position = c(0.3, 0.8)) + ggtitle(paste0("α=", alpha3$alpha))

#combine
ggpubr::ggarrange(plot1,plot2,plot3,ncol=3) +
  ggtitle("Majority illusion in scale-free networks") + theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16)
  )
``` 

<br>

now for each parameter space row generate N different networks:

<!--library(foreach)
library(doParallel)
#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores-1) 
registerDoParallel(cl)

#set up calculations and run in foreach loop
n = 1000

big_list <- foreach(i=1:n) %dopar% {
  big_list[i] = i^2
}

print(big_list)

#stop cluster
stopCluster(cl)-->

```{r, eval=FALSE}
nIter <- 50

rep_results <- list()

for (alpha in alphas) {
  for (iter in 1:nIter) {
    print(paste0("Running iteration ", iter, "/", nIter, " for alpha = ", alpha))  
    degseq <- fdegseq(n=n, alpha=alpha, k_min=k_min, seed = 123+iter) #modify seed over each run
    network <- sample_degseq(degseq, method = "vl")
    V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))
    
    for (target_r in target_r_values[[as.character(alpha)]]) {
      rewired_network <- frewire_r(network, target_r, verbose = FALSE)
      actual_r <- assortativity_degree(rewired_network)
      
      for (target_rho in target_rho_values) { 
        final_network <- fswap_rho(rewired_network, target_rho, verbose = FALSE)
        final_rho <- fdegtraitcor(final_network)$cor
        
          mi <- calculate_majority_illusion(final_network)
          
        rep_results <- append(rep_results, list(list(
          alpha = alpha,
          target_r = target_r,
          actual_r = actual_r,
          target_rho = target_rho,
          actual_rho = final_rho,
          mi = mi
        )))
      }
    }
  }
}
 
df <- do.call(rbind, lapply(rep_results, function(res) {
  data.frame(
    alpha = res$alpha,
    target_r = res$target_r,
    actual_r = res$actual_r,
    target_rho = res$target_rho,
    actual_rho = res$actual_rho,
    mi = res$mi
  )
}))

#save output..
fsave(rep_results, "networks.Rda")
fsave(df, "sim_nets.Rda")
```
```{r}
df <- fload("./data/processed/20241206sim_nets.Rda")

#fit models
m1 <- lm(mi ~ actual_rho + actual_r + as.factor(alpha), data = df)
m2 <- lm(mi ~ actual_rho + actual_r + as.factor(alpha) + actual_rho:actual_r, data = df)
m3 <- lm(mi ~ actual_rho + actual_r + as.factor(alpha) + actual_rho:actual_r + actual_rho:as.factor(alpha) + actual_r:as.factor(alpha), data = df)

anova(m1,m2,m3)
summary(m3)

# create a sequence of values for rho, r, and alpha
rho_vals <- seq(min(df$actual_rho), max(df$actual_rho), length.out = 50)
r_vals <- seq(min(df$actual_r), max(df$actual_r), length.out = 50)
#alpha_vals <- seq(2.4, 3, by=0.1)  
alpha_vals <-c(2.4,2.7,3)

# function to generate the surface data for a given alpha value
fsurfacedat <- function(alpha_val) {
  # create a grid of r and rho values
  grid <- expand.grid(actual_r = r_vals, actual_rho = rho_vals)
  
  # fixed alpha value
  grid$alpha <- alpha_val
  
  # predict the values of mi using the model
  grid$mi_pred <- predict(m3, newdata = grid)
  
  # reshape the predicted values into a matrix
  mi_matrix <- matrix(grid$mi_pred, nrow = length(r_vals), ncol = length(rho_vals), byrow = TRUE)
  
  return(mi_matrix)
}

library(plotly)

# precompute the surface data for all alpha values
surface_data_list <- lapply(alpha_vals, fsurfacedat)

# find the global range of MM (z values)
z_min <- min(sapply(surface_data_list, min))
z_max <- max(sapply(surface_data_list, max))

# create the initial surface plot with the first alpha value
fig <- plot_ly(
  x = r_vals,  # x-axis: r
  y = rho_vals,  # y-axis: rho
  z = surface_data_list[[1]],  # surface data for the first alpha
  type = "surface",
  colorscale = "Viridis",
  colorbar = list(
    title = "Pred. MM",
    cmin = z_min, 
    cmax = z_max
  ),
  cmin = z_min,  
  cmax = z_max,
  hovertemplate = paste(
    "r_{kk}: %{x:.2f}<br>",  
    "ρ_{xk}: %{y:.2f}<br>",  
    "MM: %{z:.2f}<extra></extra>"
  )
)

# add slider for dynamic alpha selection
fig <- fig %>%
  layout(
    title = paste("Predicted Majority Illusion from OLS model for α =", alpha_vals[1]),
    scene = list(
      xaxis = list(title = "r_{kk}"),
      yaxis = list(title = "ρ_{kx}"),
      zaxis = list(
        title = "MM",
        range = c(z_min, z_max) 
      )
    ),
    sliders = list(
      list(
        active = 0,  # start with the first alpha value
        steps = lapply(seq_along(alpha_vals), function(i) {
          list(
            method = "update",
            args = list(
              list(
                z = list(surface_data_list[[i]])  #update surface data
              ),
              list(
                title = paste("Predicted Majority Illusion from OLS model for α =", alpha_vals[i])  # update title
              )
            ),
            label = as.character(alpha_vals[i])  # slider label
          )
        }),
        currentvalue = list(
          prefix = "α: ",  # text displayed next to the slider
          font = list(size = 16)
        )
      )
    )
  )

fig

```


---

# simulation function



```{r}
fabm <- function(N=96, p_t=0.10,
                 alpha=2.4, k_min=3,
                 r=-0.1, rho=0,
                 rounds=10, 
                 s=10, e=10, w=30, z=35, 
                 choice_rule="deterministic", utility_fn=futility,
                 seed=NULL) {
  
  # create network
  degseq <- fdegseq(n=N, alpha=alpha, k_min=k_min)
  network <- sample_degseq(degseq, method = "vl")
  
  # assign roles randomly
  V(network)$role <- sample(c(rep("trendsetter", floor(N*p_t)), rep("conformist", N - floor(N*p_t))))
  
  # manipulate degree assortativity
  network <- frewire_r(network, target_r = r, verbose = FALSE)
  
  # manipulate degree-trait correlation
  network <- fswap_rho(network, target_rho = rho, verbose = TRUE)
  
  # make an agents dataframe
  agents <- tibble(
    id = 1:N,
    role = V(network)$role,
    preference = ifelse(role == "trendsetter", 1, 0), # 1 = follow trend, 0 = not follow
    choice = NA
  )
  
  # initialize decision history
  decision_history <- tibble()
  
  # simulation loop
  for (t in 1:rounds) {
    if (t == 1) {
      # round 1: agents make decisions based on private preferences (no social information)
      agents <- agents %>%
        mutate(choice = preference)
    } else {
      # round t > 1: agents make decisions based on social information from neighbors (decisions at t-1)
      agents <- agents %>%
        rowwise() %>%
        mutate(
          util_1 = utility_fn(id, 1, agents, network, list(s = s, e = e, w = w, z = z))$utility,
          util_0 = utility_fn(id, 0, agents, network, list(s = s, e = e, w = w, z = z))$utility,
          # make decision based on expected utility
          choice = ifelse(
            choice_rule == "deterministic",
            ifelse(util_1 > util_0, 1, 0),  # deterministic rule
            sample(c(1, 0), size = 1, prob = c(exp(util_1), exp(util_0)))  # probabilistic rule (@RF: only for conformists? level of noise?)
          )
        )
    }
    # store the decisions for this round
    decision_history <- bind_rows(decision_history, agents %>% 
                                    mutate(round = t))
  }
  return(decision_history)
}
  
fabm(N=96, p_t=0.1,alpha=2.4,k_min=3,r=-0.1, rho=0,rounds=10,s=10,e=10,w=30,z=35,seed=123)

```