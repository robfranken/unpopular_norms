---
title: "ABM"
bibliography: references.bib
link-citations: true
date: "Last compiled on `r format(Sys.time(), '%d-%m-%Y')`"
output: 
  html_document:
    css: tweaks.css
    toc:  true
    toc_float: true
    number_sections: true
    toc_depth: 4
    code_folding: show
    code_download: yes
---

```{r, globalsettings, echo=FALSE, warning=FALSE, results='hide', message=FALSE}
library(knitr)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, message = FALSE,comment = "#>", cache=TRUE, class.source=c("test"), class.output=c("test3"))
options(width = 100)
rgl::setupKnitr()

colorize <- function(x, color) {sprintf("<span style='color: %s;'>%s</span>", color, x) }
```


```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
#klippy::klippy(color = 'darkred')
#klippy::klippy(tooltip_message = 'Click to copy', tooltip_success = 'Done')
```

---  


```{r, results='hide'}
rm(list=ls())
gc()
```

```{r, packages, warning=FALSE, message=FALSE, results='hide'}
fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fshowdf <- function(x, ...) {
    knitr::kable(x, digits = 2, "html", ...) %>%
        kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
        kableExtra::scroll_box(width = "100%", height = "300px")
}

fsave <- function(x, location = "./data/processed/") {
  if (location == "./data/processed/") {
  ifelse(!dir.exists("data"), dir.create("data"), FALSE)
  ifelse(!dir.exists("data/processed"), dir.create("data/processed"), FALSE)
  }
  object = deparse(substitute(x))
  datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
  totalname <- paste(location, object, "_", datename,  ".rda", sep = "")
  assign(eval(object), x, envir = .GlobalEnv)
  print(paste("SAVED: ", totalname, sep = ""))
  save(list = object, file = totalname)  
}

packages = c("tidyverse", "igraph", "grid", "cowplot", "purrr")
fpackage.check(packages)
rm(packages)

#library(furrr)
#library(future)
#library(parallel)
```

---

# utility function

```{r}
futility <- function(agent_id, choice, agents, network, params) {
  # get ego and his local neighborhood
  ego <- agents[agent_id, ]
  neighbors <- neighbors(network, ego$id)
  alters <- agents[as.numeric(neighbors), ]
  n <- nrow(alters)

  # count number of neighbors who did (not) follow the trend
  n1 <- sum(alters$choice == 1)
  n0 <- sum(alters$choice == 0)
  
  # calculate expected utility (depending on alters' choices in prior round)
  if(ego$role == "conformist") {
    choice_payoff <- ifelse(choice == 0, params$s, 0)
    coordination_payoff <- ifelse(choice == 0, # normalized by n
                                  (params$w/n) * n0,
                                  (params$z/n) * n1)
  } else {
    choice_payoff <- ifelse(choice == 1, params$e, 0)
    coordination_payoff <- 0
  }
  return(list(utility = choice_payoff + coordination_payoff,
              n1 = n1, n0 = n0))
}
```


----

# plot network graph

```{r}
#visualize the network topology and agent positions (degree-trait correlation)
fplot_graph <- function(graph, main=NULL, layout_algo=NULL, 
                        col1 = "#FFD700", col2 = "#800080") {
  plot(graph,
       main = main,
       layout = layout_algo,
       vertex.label = NA,
       vertex.size = degree(graph) * 0.6 + 4, # node size based on degree
       vertex.color = ifelse(V(graph)$role == "trendsetter", col1, col2),
       edge.width = 0.5,
       edge.color = "darkgrey")
  #add legend
  legend("bottomleft",
         legend = c("Trendsetter", "Conformist"),
         pch = 21,
         col = c(col1,col2),
         pt.bg = c(col1,col2),
         pt.cex = 3,
         bty = "n")
}
```

----

# preferential attachment model

```{r}
# scale-free network using preferential attachment algorithm
n = 96
m = 3
alpha = 1.5
t = .1
network <- sample_pa(n = n, m = m, power = alpha, directed = FALSE)
V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))
sort(degree(network))
fplot_graph(network)
``` 


---


# configuration model

```{r}
# generate random graphs based on a degree sequence generated by a power law distribution
fdegseq <- function(n, alpha, k_min = 1, k_max = n-1) {
  # sample degree sequence
  degseq <- sample(
    k_min:k_max, 
    size = n, 
    replace = TRUE, 
    prob = (1 / (k_min:k_max))^alpha) 
  # correct the degree sequence if its sum is odd (necessary for the configuration model)
  if( sum(degseq) %% 2 != 0) {
    degseq[1] <- degseq[1] + 1
  }
  return(degseq)
}

degseq <- fdegseq(n=96, alpha=3.1, k_min=3)
network <- sample_degseq(degseq, method = "vl")
is_simple(network)
sort(degree(network))

# randomly assign roles, based on proportion trendsetters
V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))

#visualize graph
fplot_graph(network)

#alpha 2.1 creates average degree of ~ 8.5
#alpha 2.4 creates average degree of ~ 6.9
#alpha 3.1 creates average degree of ~ 4.8
#@RF: loop over high number of simulated configuration models to get an accurate average <k>

# to produce random networks with same average degree; tweak edge probability
# <k> = p * (n-1); with p being edge probability
# p = <k> / (n-1)
# 8.5 / 95 ~ 0.09
# 6.9 / 95 ~ 0.07
# 4.8 / 95 ~ 0.05
``` 

---


# rewiring to manipulate degree-assortativity

```{r}
#rewiring function to adjust assortativity (r) to desired level; Newman:
frewire_r <- function(network, target_r, max_iter = 1e5, tol = 0.01, verbose = TRUE) {
  
  current_r <- assortativity_degree(network)
  iteration <- 1
  
  if (verbose) {
    cat("Target assortativity coefficient:", target_r, "\n")
    cat("Starting assortativity coefficient:", current_r, "\n")
    cat("Tolerance:", tol, "\n")
  }
  
  while (abs(current_r - target_r) > tol && iteration < max_iter) {
    
    # get network edges
    edges <- E(network)
    # to edgelist
    edge_list <- ends(network, edges)
    
    # randomly select two pairs of connected nodes
    idx1 <- sample(1:nrow(edge_list), 1)
    idx2 <- sample(1:nrow(edge_list), 1)
    
    # extract node indices
    u1 <- edge_list[idx1, 1] # node 1 of first edge
    v1 <- edge_list[idx1, 2] # node 2 of first edge
    u2 <- edge_list[idx2, 1] # etc
    v2 <- edge_list[idx2, 2] 
    
    # check if the two pairs of connected nodes (u1, v1; u2, v2) are disjoint
    if (length(unique(c(u1, v1, u2, v2))) == 4) {
      # check if there is already an edge across the node-pairs
      # ensure no loops and no duplicate edges
      if (!are_adjacent(network, u1, u2) && !are_adjacent(network, v1, v2) && u1 != v2 && u2 != v1) {
        
        # perform the edge swap (u1,v1) <-> (u2,v2) becomes (u1,v2) <-> (u2,v1)
        new_network <- network # Copy network
        
        # check if the new edges already exist to avoid duplicates
        if (!are_adjacent(new_network, u1, v2) && !are_adjacent(new_network, u2, v1)) {
          # add edges
          new_network <- add_edges(new_network, c(u1, v2, u2, v1))
          # remove edges
          new_network <- delete_edges(new_network, get.edge.ids(new_network, c(u1, v1, u2, v2)))
          
          # new assortativity
          new_r <- assortativity_degree(new_network)
          
          # accept tie swap if it brings us closer to the target assortativity
          if (abs(new_r - target_r) < abs(current_r - target_r)) {
            current_r <- new_r
            network <- new_network
            if (verbose) { 
              cat("Rewiring at iteration", iteration, "brought assortativity closer to target! Current assortativity coefficient:", new_r, "\n")
            }
          }
        }
      }
    }
    iteration <- iteration + 1
  }
  
  if (verbose) {
    cat("Final assortativity coefficient:", current_r, "\n")
    if (abs(current_r - target_r) <= tol) {
      cat("Target reached within tolerance.\n")
    } else {
      cat("Reached maximum iterations without meeting target.\n")
    }
  }
  
  return(network)
}

#initialize scale-free network
degseq <- fdegseq(n=96, alpha=2.4, k_min=3)
network <- sample_degseq(degseq, method = "vl")
V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))

#get current assortativity coefficient
assortativity_degree(network)

#set target
target = -0.1
network2 <- frewire_r(network, target_r = target, max_iter = 1e3)
```

---

# swapping traits to manipulate degree-trait correlation

```{r}
# we manipulate degree-trait correlation (rho) by swapping attribute values among the nodes. To increase \rho_{kx}, we randomly choose nodes v_1 with x=1 and v_0 with x=0 and swap their attributes if the degree of the degree of v_0 is greater than that of v_1 (until the desired \rho_{kx} is reached; or it no longer changes).
fdegtraitcor <- function(network){
  roles <- ifelse(V(network)$role == "trendsetter", 1, 0)
  degrees <- degree(network)
  return(list(cor=cor(roles,degrees),roles=roles,degrees=degrees))
}

#swapping function to adjust degree-trait correlation
fswap_rho <- function(network, target_rho, max_iter = 1e3, tol = 0.05, verbose = TRUE) {
  
  current <- fdegtraitcor(network)
  iteration <- 1
  best_network <- network
  best_rho <- current$cor
  
  if (verbose) {
    cat("Target degree-trait correlation:", target_rho, "\n")
    cat("Starting degree-trait correlation:", current$cor, "\n")
    cat("Tolerance:", tol, "\n\n")
  }
  
  while (iteration <= max_iter) {
    # check if we are already within tolerance
    if (abs(current$cor - target_rho) <= tol) {
      if (verbose) cat("Target reached within tolerance at iteration", iteration, ".\n")
      break
    }
    
    # randomly select nodes for swapping
    v1 <- sample(which(current$roles == 1), 1)
    v0 <- sample(which(current$roles == 0), 1)
    
    # get degrees of selected nodes
    k1 <- current$degrees[v1]
    k0 <- current$degrees[v0]
    
    # swap roles if condition k_v0 > k_v1 is met
    if (k0 > k1) {
      current$roles[v1] <- 0
      current$roles[v0] <- 1
      
      # update graph roles
      V(network)$role <- ifelse(current$roles == 1, "trendsetter", "conformist")
      
      # recalculate degree-trait correlation
      current <- fdegtraitcor(network)
      
      # check if this is the closest correlation to the target so far
      if (abs(current$cor - target_rho) < abs(best_rho - target_rho)) {
        best_network <- network
        best_rho <- current$cor
        if (verbose) {
          cat("Trait-swapping at iteration", iteration, "brought correlation closer to target! Current correlation:", current$cor, "\n")
        }
      }
    }
    iteration <- iteration + 1
  }
  
  # check if the final correlation is worse than the best correlation
  final_correlation <- current$cor
  if (abs(final_correlation - target_rho) > abs(best_rho - target_rho)) {
    if (verbose) {
      cat("\nWarning: Final iteration made the correlation worse. Reverting to best observed correlation.\n")
    }
  }
  
  if (verbose) {
    cat("\nFinal degree-trait correlation:", best_rho, "\n")
    if (abs(best_rho - target_rho) <= tol) {
      cat("Target reached within tolerance.\n")
    } else if (iteration > max_iter) {
      cat("Reached maximum iterations without meeting target.\n")
    }
  }
  return(best_network)
}

fdegtraitcor(network)
target = 0.5
fdegtraitcor(fswap_rho(network = network, target_rho = target, tol=0.01))
``` 

```{r}
fplot_graph(network,
            main=paste0("configuration model\ndegree sequence generated from p(k)~k^{-α}\nN=96; prop. trendsetter = 0.1; α=2.4; k_min=3\nr_kk = ", 
                        round(assortativity_degree(network),3), 
                        "; p_kx = ", round(fdegtraitcor(network)$cor,3)))

network2 <- frewire_r(network, target_r = -0.1, max_iter = 1e5, verbose=FALSE)

fplot_graph(network2,
            main=paste0("configuration model\ndegree sequence generated from p(k)~k^{-α}\nN=96; prop. trendsetter = 0.1; α=2.4; k_min=3\nr_kk = ", 
                        round(assortativity_degree(network2),3), 
                        "; p_kx = ", round(fdegtraitcor(network2)$cor,3)))

network3 <- fswap_rho(network2, target_rho = 0.5, max_iter = 1e5, verbose=FALSE)

fplot_graph(network3,
            main=paste0("configuration model\ndegree sequence generated from p(k)~k^{-α}\nN=96; prop. trendsetter = 0.1; α=2.4; k_min=3\nr_kk = ", 
                        round(assortativity_degree(network3),3), 
                        "; p_kx = ", round(fdegtraitcor(network3)$cor,3)))
```

---

Simulate scale-free networks with independently varied degree distribution, degree assortativity, and degree-trait correlation:

```{r, eval=FALSE}
# structural parameters
n = 96
k_min = 3
p_t = 0.1

# target parameters
alphas <- c(2.1, 2.4, 3.1)
target_r_values <- seq(-0.4, 0.4, by = 0.1) 
target_rho_values <- seq(0, 0.6, by = 0.1)

# list for results
results <- list()

for (alpha in alphas) { #loop over alpha
  
  # generate degree sequence from power law with alpha
  degseq <- fdegseq(n = n, alpha = alpha, k_min = k_min)
  
  # create undirected, connected, simple graph using Viger-Latapy algorithm
  network <- sample_degseq(degseq, method = "vl")
  
  # assign roles randomly, based on proportion trendsetter p_t
  V(network)$role <- sample(c(rep("trendsetter", floor(n*t)), rep("conformist", n - floor(n*t))))
  
  for (target_r in target_r_values) { #loop over target_r values
    rewired_network <- frewire_r(network, target_r, verbose=FALSE, max_iter = 1e4)
    actual_r <- assortativity_degree(rewired_network)
    
    for (target_rho in target_rho_values) { #loop over target_rho values
      final_network <- fswap_rho(rewired_network, target_rho, verbose=FALSE, max_iter=1e4)
      final_rho <- fdegtraitcor(final_network)$cor
      
      # store results
      results <- append(results, list(list(
        alpha = alpha,
        target_r = target_r,
        actual_r = actual_r,
        target_rho = target_rho,
        actual_rho = final_rho,
        network = final_network
      )))
    }
  }
}

#save(results, file = "./data/networks.rda")
```

```{r, fig.width=12,fig.height=6}
#load in the generated networks
load("./data/networks.rda")

# function to calculate magnitude of majority illusion; over different network structures;
calculate_majority_illusion <- function(network, threshold = 0.5) {
  roles <- V(network)$role

  #initialize counter for majority illusion
  mi_count <- 0
  
  #loop over conformists
  for (v in V(network)) {
    if (roles[v] == "conformist") {
      neighbors <- neighbors(network, v)
      trend_neighbors <- sum(roles[neighbors] == "trendsetter")
      prop_trend <- trend_neighbors / length(neighbors)
      
      if (prop_trend > threshold) {
        mi_count <- mi_count + 1
      }
    }
  }
  # return fraction of conformists who have majority illusion
  return(mi_count / sum(roles == "conformist"))
}

plotdata <- do.call(rbind, lapply(results, function(res) {
  alpha <- res$alpha
  r <- res$actual_r
  rho <- res$actual_rho
  network <- res$network
  
  # calculate the majority illusion (i.e., the proportion of conformists whose neighbors meet or exceed threshold φ)
  mi <- calculate_majority_illusion(network)
  
  # create a dataframe
  data.frame(alpha = alpha, 
             r = r, 
             rho = rho, 
             mi = mi)
}))

#make separate dataframes for each level of alpha
alpha1 <- plotdata[plotdata$alpha==unique(plotdata$alpha)[1],]
alpha2 <- plotdata[plotdata$alpha==unique(plotdata$alpha)[2],]
alpha3 <- plotdata[plotdata$alpha==unique(plotdata$alpha)[3],]

#create bins for r (deg-assorativity)
fcreate_bins <- function(data, variable = "r") {
  rvals <- data[[variable]]
  quant <- quantile(rvals, probs = seq(0, 1, length.out = 6)) 
  # generate labels dynamically
  labels <- sapply(1:(length(quant) - 1), function(i) {
    paste0(round(quant[i], 2), " < r ≤ ", round(quant[i + 1], 2))
  })
  # add categories to the dataset
  data$r_cats <- cut(rvals, breaks = quant, include.lowest = TRUE, labels = labels)
  return(data)
}

# apply binning  to each subset
alpha1 <- fcreate_bins(alpha1)
alpha2 <- fcreate_bins(alpha2)
alpha3 <- fcreate_bins(alpha3)

#plot
plot1 <- ggplot(alpha1, aes(x = rho, y = mi, color = as.factor(r_cats))) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(se = FALSE, method = "loess") +
  scale_y_continuous(limits = c(0, 0.3)) +
  labs(
    x = expression("degree-trait correlation (" ~ rho[kx] ~ ")"), 
    y = "prop. conformists w/ prop. trendsetter nbh. > φ",      
    color = expression("degree assortativity (" ~ r[kk] ~ ")")
  ) +
  theme(legend.position = c(0.3, 0.8)) + ggtitle(paste0("α=", alpha1$alpha))

plot2 <- ggplot(alpha2, aes(x = rho, y = mi, color = as.factor(r_cats))) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(se = FALSE, method = "loess") +
  scale_y_continuous(limits = c(0, 0.3)) +
  labs(
    x = expression("degree-trait correlation (" ~ rho[kx] ~ ")"), 
    y = "prop. conformists w/ prop. trendsetter nbh. > φ",      
    color = expression("degree assortativity (" ~ r[kk] ~ ")")
  ) +
  theme(legend.position = c(0.3, 0.8)) + ggtitle(paste0("α=", alpha2$alpha))

plot3 <- ggplot(alpha3, aes(x = rho, y = mi, color = as.factor(r_cats))) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(se = FALSE, method = "loess") +
  scale_y_continuous(limits = c(0, 0.3)) +
  labs(
    x = expression("degree-trait correlation (" ~ rho[kx] ~ ")"), 
    y = "prop. conformists w/ prop. trendsetter nbh. > φ",      
    color = expression("degree assortativity (" ~ r[kk] ~ ")")
  ) +
  theme(legend.position = c(0.3, 0.8)) + ggtitle(paste0("α=", alpha3$alpha))

#combine
ggpubr::ggarrange(plot1,plot2,plot3,ncol=3) +
  ggtitle("Majority illusion in scale-free networks") + theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16)
  )
``` 


    
    

